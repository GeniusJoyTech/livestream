import asyncio
import json
import mss
import cv2
import numpy as np
import websockets
from aiortc import RTCPeerConnection, RTCSessionDescription, VideoStreamTrack
from aiortc.sdp import candidate_from_sdp
from av import VideoFrame
import platform
nome_computador = platform.node()

class ScreenCaptureTrack(VideoStreamTrack):
    def __init__(self, monitor_number=1, fps=30):
        super().__init__()
        self.sct = mss.mss()
        self.monitor_number = int(monitor_number)
        self.fps = fps
        self.update_monitor()

    def update_monitor(self):
        total_monitors = len(self.sct.monitors) - 1
        if self.monitor_number <= 0 or self.monitor_number > total_monitors:
            self.monitor_number = 1
        self.monitor = self.sct.monitors[self.monitor_number]
        print(f"üñ•Ô∏è Capturando monitor {self.monitor_number}: {self.monitor}")

    async def recv(self):
        pts, time_base = await self.next_timestamp()
        img = np.array(self.sct.grab(self.monitor))
        img = cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)
        frame = VideoFrame.from_ndarray(img, format='bgr24')
        frame.pts = pts
        frame.time_base = time_base
        await asyncio.sleep(1 / self.fps)
        return frame

class Broadcaster:
    def __init__(self, signaling_url, broadcaster_name="Broadcast Padr√£o", company_id="0"):
        self.signaling_url = signaling_url
        self.broadcaster_name = broadcaster_name
        self.company_id = company_id
        self.peers = {}  # viewer_id -> RTCPeerConnection
        self.should_reconnect = True

    async def connect(self):
        retry_delay = 1
        while self.should_reconnect:
            try:
                print(f"üîå Tentando conectar ao servidor de sinaliza√ß√£o: {self.signaling_url}")
                async with websockets.connect(self.signaling_url) as socket:
                    print("‚úÖ Conectado ao servidor de sinaliza√ß√£o.")
                    retry_delay = 1

                    # Registro do broadcaster
                    await socket.send(json.dumps({
                        "type": "broadcaster",
                        "monitor_number": 1,
                        "broadcaster_name": self.broadcaster_name,
                        "company_id": self.company_id
                    }))
                    print(f"üì° Registrado como: {self.broadcaster_name}")

                    async for msg in socket:
                        data = json.loads(msg)
                        if data["type"] == "new-viewer":
                            await self._handle_new_viewer(socket, data)
                        elif data["type"] == "answer":
                            await self._handle_answer(data)
                        elif data["type"] == "candidate":
                            await self._handle_candidate(data)
                        elif data["type"] == "viewer-disconnected":
                            await self._handle_viewer_disconnected(data)

            except (websockets.exceptions.ConnectionClosedError, ConnectionRefusedError) as e:
                print(f"‚ö†Ô∏è Conex√£o perdida ({type(e).__name__}): tentando reconectar em {retry_delay}s...")
                await asyncio.sleep(retry_delay)
                retry_delay = min(retry_delay * 2, 30)
            except Exception as e:
                print(f"‚ùå Erro inesperado: {e}")
                await asyncio.sleep(5)
        print("üõë Reconex√£o desativada, encerrando.")

    async def _handle_new_viewer(self, socket, data):
        viewer_id = data["viewerId"]
        monitor_number = int(data.get("monitor_number", 1))
        print(f"üëÄ Novo viewer {viewer_id} solicitou monitor {monitor_number}")

        # Cria uma nova conex√£o para cada viewer
        video_track = ScreenCaptureTrack(monitor_number=monitor_number)
        pc = RTCPeerConnection()
        pc.addTrack(video_track)

        @pc.on("icecandidate")
        async def on_icecandidate(event):
            if event.candidate:
                await socket.send(json.dumps({
                    "type": "candidate",
                    "candidate": {
                        "candidate": event.candidate.candidate,
                        "sdpMid": event.candidate.sdpMid,
                        "sdpMLineIndex": event.candidate.sdpMLineIndex
                    },
                    "targetId": viewer_id
                }))

        @pc.on("connectionstatechange")
        async def on_connectionstatechange():
            print(f"üì∂ Estado da conex√£o com {viewer_id}: {pc.connectionState}")
            if pc.connectionState in ["failed", "disconnected", "closed"]:
                await self._handle_viewer_disconnected({"viewerId": viewer_id})

        offer = await pc.createOffer()
        await pc.setLocalDescription(offer)

        self.peers[viewer_id] = pc

        await socket.send(json.dumps({
            "type": "offer",
            "sdp": {
                "type": pc.localDescription.type,
                "sdp": pc.localDescription.sdp
            },
            "targetId": viewer_id
        }))
        print(f"üì§ Offer enviado para {viewer_id} ‚Äî {len(self.peers)} viewer(s) conectados.")

    async def _handle_answer(self, data):
        viewer_id = data["senderId"]
        pc = self.peers.get(viewer_id)
        if not pc:
            return

        # Evita erro "Cannot handle answer in signaling state 'stable'"
        if pc.signalingState != "have-local-offer":
            print(f"‚ö†Ô∏è Ignorando answer de {viewer_id} ‚Äî estado: {pc.signalingState}")
            return

        await pc.setRemoteDescription(
            RTCSessionDescription(
                sdp=data["sdp"]["sdp"],
                type=data["sdp"]["type"]
            )
        )
        print(f"‚úÖ Answer recebida de {viewer_id}")

    async def _handle_candidate(self, data):
        viewer_id = data["senderId"]
        pc = self.peers.get(viewer_id)
        if pc:
            c = data["candidate"]
            cand = candidate_from_sdp(c["candidate"])
            cand.sdpMid = c["sdpMid"]
            cand.sdpMLineIndex = c["sdpMLineIndex"]
            await pc.addIceCandidate(cand)
            print(f"‚ûï Candidate adicionado de {viewer_id}")

    async def _handle_viewer_disconnected(self, data):
        viewer_id = data["viewerId"]
        pc = self.peers.pop(viewer_id, None)
        if pc:
            await pc.close()
            print(f"üëã Viewer {viewer_id} desconectado.")
        if not self.peers:
            print("üõë Nenhum viewer ativo ‚Äî transmiss√£o encerrada.")

    async def stop(self):
        self.should_reconnect = False
        for pc in self.peers.values():
            await pc.close()
        self.peers.clear()
        print("üßπ Broadcaster encerrado e conex√µes limpas.")

if __name__ == "__main__":
    signaling_url = "wss://ee33b7a2-f8ee-40e6-907a-76ce0960df87-00-3c0nxu863cqln.janeway.replit.dev?role=broadcaster"  # agora com o papel na URL
    company_id = "1"
    broadcaster = Broadcaster(signaling_url, broadcaster_name=nome_computador, company_id=company_id)
    try:
        asyncio.run(broadcaster.connect())
    except KeyboardInterrupt:
        print("\nüõë Encerrando transmiss√£o...")
        asyncio.run(broadcaster.stop())
