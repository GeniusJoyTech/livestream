<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <title>Viewer DinÃ¢mico</title>
</head>

<body>
  <h2>ğŸ‘€ Assistindo a transmissÃ£o</h2>

  <button id="connectButton">ğŸ”Œ Conectar</button>
  <br><br>

  <label for="broadcasterSelect">Escolha um broadcaster:</label>
  <select id="broadcasterSelect"></select>
  <br>

  <label for="monitorSelect">Escolha um monitor:</label>
  <select id="monitorSelect">
    <option value="1">Monitor 1</option>
    <option value="2">Monitor 2</option>
  </select>

  <button id="watchButton">â–¶ï¸ Assistir</button>

  <video id="remoteVideo" autoplay playsinline style="width: 80%; border: 2px solid black; margin-top:10px;"></video>

  <script>
    const connectButton = document.getElementById('connectButton');
    const watchButton = document.getElementById('watchButton');
    const broadcasterSelect = document.getElementById('broadcasterSelect');
    const monitorSelect = document.getElementById('monitorSelect');
    const remoteVideo = document.getElementById('remoteVideo');

    let socket;
    let peers = new Map();
    let selectedBroadcasterId = null;
    let selectedMonitorNumber = null;
    let broadcasters = []; // Lista atual de broadcasters

    // ============================
    // BotÃ£o Conectar
    // ============================
    connectButton.onclick = () => {
      connectButton.disabled = true;
      connectButton.textContent = 'Conectando...';

      // Conectar ao WebSocket do servidor de sinalizaÃ§Ã£o
      socket = new WebSocket(`ws://${location.host}`);

      socket.onopen = () => {
        console.log('WebSocket conectado');
        socket.send(JSON.stringify({ type: 'viewer' }));
        connectButton.style.display = 'none';  // Esconde o botÃ£o apÃ³s conectar
      };

      socket.onmessage = async (event) => {
        const message = JSON.parse(event.data);

        switch (message.type) {

          // Lista de broadcasters disponÃ­veis
          case 'broadcaster-list':
            broadcasters = message.broadcasters;
            updateSelect();  // Atualiza o select com os broadcasters disponÃ­veis
            break;

          // Novo broadcaster entrou
          case 'new-broadcaster':
            if (!broadcasters.includes(message.broadcasterId)) {
              broadcasters.push(message.broadcasterId);
              updateSelect();
            }
            break;

          // Broadcaster saiu
          case 'broadcaster-left':
            broadcasters = broadcasters.filter(id => id !== message.broadcasterId);
            updateSelect();

            if (selectedBroadcasterId === message.broadcasterId) {
              remoteVideo.srcObject = null;  // Remove o vÃ­deo do broadcaster que saiu
              selectedBroadcasterId = null;
              selectedMonitorNumber = null;
              alert(`âŒ O broadcaster ${message.broadcasterId} saiu.`);
            }
            break;

          // Recebe oferta de WebRTC (SDP)
          case 'offer':
            const pc = createPeerConnection(message.senderId, message.monitor_number);
            peers.set(message.senderId, pc);

            await pc.setRemoteDescription(new RTCSessionDescription(message.sdp));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);

            // Envia a resposta de WebRTC (SDP)
            socket.send(JSON.stringify({
              type: 'answer',
              sdp: pc.localDescription,
              targetId: message.senderId
            }));
            break;

          // ICE Candidate recebido
          case 'candidate':
            const candidatePc = peers.get(message.senderId);
            if (candidatePc) {
              await candidatePc.addIceCandidate(new RTCIceCandidate(message.candidate));
            }
            break;
        }
      };
    };

    // ============================
    // BotÃ£o Assistir
    // ============================
    watchButton.onclick = () => {
      selectedBroadcasterId = broadcasterSelect.value;
      selectedMonitorNumber = monitorSelect.value;

      if (!selectedBroadcasterId || !selectedMonitorNumber || !socket || socket.readyState !== WebSocket.OPEN) return;

      console.log(`Assistindo broadcaster: ${selectedBroadcasterId} - Monitor: ${selectedMonitorNumber}`);

      // Envia a mensagem para o servidor para assistir ao broadcaster escolhido
      socket.send(JSON.stringify({
        type: 'watch',
        targetId: selectedBroadcasterId,
        monitor_number: selectedMonitorNumber
      }));
    };

    // ============================
    // Atualiza o select com a lista de broadcasters
    // ============================
    function updateSelect() {
      broadcasterSelect.innerHTML = '';  // Limpa as opÃ§Ãµes atuais

      // Adiciona novos broadcasters ao select
      broadcasters.forEach(id => {
        const option = document.createElement('option');
        option.value = id;
        option.textContent = `Broadcaster ${id}`;
        broadcasterSelect.appendChild(option);
      });
    }

    // ============================
    // Cria uma conexÃ£o WebRTC
    // ============================
    function createPeerConnection(id, monitor_number) {
      const pc = new RTCPeerConnection({
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
      });

      pc.onicecandidate = (event) => {
        if (event.candidate && socket.readyState === WebSocket.OPEN) {
          socket.send(JSON.stringify({
            type: 'candidate',
            candidate: event.candidate,
            targetId: id
          }));
        }
      };

      pc.ontrack = (event) => {
        if (remoteVideo.srcObject !== event.streams[0]) {
          remoteVideo.srcObject = event.streams[0];  // Exibe o stream no video element
          remoteVideo.play().catch(e => console.warn('Erro ao iniciar play:', e));
        }
      };

      return pc;
    }
  </script>
</body>

</html>
